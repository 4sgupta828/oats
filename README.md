# UF-Flow: An Autonomous Agentic Framework ðŸš€

UF-Flow is a Python-based framework for building, orchestrating, and running autonomous AI agents. It's designed to bridge the gap between high-level human goals and executable, real-world actions. The framework transforms ambiguous objectives into adaptive, auditable, and resilient workflows powered by a blend of Large Language Models (LLMs) and a robust, deterministic execution engine.

The core of UF-Flow is an **agentic loop** that allows the system to plan, act, observe the results, and learn from its experience, all while operating within strict security and operational guardrails.

-----

## Core Concepts ðŸ“š

  * **Goal**: A high-level objective for the agent (e.g., "Deploy the web app and run a smoke test.").
  * **Plan**: A dynamic Directed Acyclic Graph (DAG) that represents the agent's current strategy for achieving a Goal. This plan is generated by an LLM and can be adapted at runtime.
  * **Unit of Flow (UF)**: An atomic, versioned, and reusable tool that the agent can execute. UFs are simple Python functions enhanced with our SDK.
  * **Orchestrator**: The "brain" of the agent. It runs a continuous control loop (Observe-Orient-Decide-Act) to execute the plan, handle failures, and make tactical decisions.
  * **Memory**: A long-term storage component that allows the agent to learn from past executions, enabling it to improve its performance over time.
  * **Registry**: A catalog of all available UFs and Policies, which the Planner uses to construct new plans.
  * **Policy Engine**: The security and governance layer. It enforces "guardrails" on agent behavior, such as budget limits or tool access permissions.

-----

## High-Level Architecture

UF-Flow is designed as a modular, layered system. In its initial implementation, these components are Python modules, but they are architected to be easily separated into event-driven microservices for scalability.

The core of the runtime is the **Agentic Loop**, where the Orchestrator continuously interacts with the World State, Memory, and Policy Engine to drive the plan to completion.

```mermaid
graph TD
    subgraph User Interaction
        A[User Goal] --> B{Planner};
    end

    subgraph Design & On-Demand Replanning
        B -- 1. Initial Strategic Plan --> C{Plan (DAG)};
        B -- Queries for UFs/Policies --> D[Registry];
    end

    subgraph Runtime: The Agentic Loop
        subgraph Orchestration Engine
            E[Observe World State] --> F[Orient & Reason];
            F -- Compare State to Goal --> G[Decide Next Action];
            G -- Adhere to Policies --> H[Act];
        end
        
        C -- Informs --> E;
        E -- Reads from --> I[World State];
        F -- Consults --> J[Memory (Learnings)];
        G -- Validates against --> K[Policy Engine];
        H -- 2. Dispatches Concrete Tool Call --> L{Tool Sandbox};
        L -- 3. Executes --> M[External Tools / APIs];
        M -- 4. Raw Output --> L;
        L -- 5. Structured Result --> I;
        I -- Updates --> C;
    end
    
    style Orchestration Engine fill:#cde4ff,stroke:#333,stroke-width:2px
```

-----

## ðŸš€ Getting Started

This guide will walk you through running the complete end-to-end example.

### 1\. Prerequisites

  * Python 3.9+
  * An OpenAI API key

### 2\. Setup

First, set up your environment and install the required dependencies.

```bash
# Set your OpenAI API key as an environment variable
export OPENAI_API_KEY="sk-..."

# Install required Python libraries
pip install pydantic openai
```

### 3\. Project Structure

Ensure your project files are organized as follows:

```
uf_flow/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ models.py
â”‚   â””â”€â”€ sdk.py
â”œâ”€â”€ registry/
â”‚   â”œâ”€â”€ discovery.py
â”‚   â””â”€â”€ main.py
â”œâ”€â”€ executor/
â”‚   â”œâ”€â”€ main.py
â”‚   â””â”€â”€ sandbox.py
â”œâ”€â”€ memory/
â”‚   â””â”€â”€ main.py
â”œâ”€â”€ orchestrator/
â”‚   â”œâ”€â”€ graph_utils.py
â”‚   â”œâ”€â”€ input_resolver.py
â”‚   â””â”€â”€ main.py
â”œâ”€â”€ planner/
â”‚   â”œâ”€â”€ main.py
â”‚   â””â”€â”€ prompts.py
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ file_system.py
â””â”€â”€ main.py
```

### 4\. Run the Example

Execute the main script from the directory *containing* the `uf_flow` folder.

```bash
python -m uf_flow.main
```

You will see the agent receive a goal, consult the LLM to generate a plan, and then execute that plan step-by-step.

-----

## Implementation Details

### Core Module (`core`)

  * **Purpose**: Defines the foundational data contracts (`models.py`) and the developer SDK (`sdk.py`). This is the universal language of the framework.
  * **Key Files**:
      * `models.py`: Contains all Pydantic models, such as `Goal`, `Plan`, `UFDescriptor`, and `WorldState`.
      * `sdk.py`: Contains the `@uf` decorator for creating new tools from simple Python functions.

### How to Create a New Tool

Creating a new tool is simple. Use the `@uf` decorator and Pydantic type hints. The registry will automatically discover and load it.

```python
# in tools/my_new_tool.py
from pydantic import Field
from ..core.sdk import uf, UfInput

class MyToolInput(UfInput):
    message: str = Field(..., description="A message to print.")

@uf(name="print_message", version="1.0.0", description="Prints a message to the console.")
def print_message(inputs: MyToolInput) -> str:
    print(inputs.message)
    return f"Successfully printed {len(inputs.message)} characters."
```

### Registry Module (`registry`)

  * **Purpose**: Discovers, loads, and provides access to all available `UFs` and `Policies`.
  * **Key Files**:
      * `discovery.py`: Scans directories for Python files containing `@uf`-decorated functions.
      * `main.py`: An in-memory store (`Registry` class) that holds all loaded tools.

### Executor Module (`executor`)

  * **Purpose**: Securely executes a single tool call in an isolated environment.
  * **Key Files**:
      * `sandbox.py`: Provides basic isolation by running tool code in a separate process using `multiprocessing`. This is designed to be replaced with a container-based solution (e.g., Docker) for production.
      * `main.py`: The `execute_tool` function, which validates inputs against a tool's schema and invokes the sandbox.

### Memory Module (`memory`)

  * **Purpose**: Provides a simple interface for the agent's long-term memory.
  * **Key Files**:
      * `main.py`: A placeholder `Memory` class with `remember` and `query` methods. This is designed to be backed by a vector database (e.g., ChromaDB, Pinecone) to enable true semantic search over past experiences.

### Orchestrator Module (`orchestrator`)

  * **Purpose**: The "brain" of the agent. It runs the main agentic loop to drive a `Plan` to completion.
  * **Key Files**:
      * `graph_utils.py`: Contains a `topological_sort` algorithm to determine the correct execution order for the plan's DAG.
      * `input_resolver.py`: Logic to prepare a tool's inputs by fetching data from the outputs of previous steps.
      * `main.py`: The main `Orchestrator` class and its `run_goal` method, which implements a simplified Observe-Orient-Decide-Act loop.

### Planner Module (`planner`)

  * **Purpose**: Translates a high-level user `Goal` into a structured, machine-executable `Plan`.
  * **Key Files**:
      * `prompts.py`: Contains the master system prompt that instructs the LLM on its role, the available tools, and the required JSON output format.
      * `main.py`: The `create_plan_for_goal` function, which formats the prompt, calls the OpenAI API, and parses the JSON response into a valid `Plan` object.

-----

## Specification & Vision

### Guiding Principles

  * **Hierarchical Reasoning**: The initial **strategic plan** is generated by an LLM, while the **tactical decisions** (like retries) are handled by the runtime agent.
  * **Goal-Orientation**: The agent is driven to achieve a **goal**, and the plan is a flexible path, not a rigid script.
  * **Bounded Autonomy**: The agent operates autonomously but within the strict **guardrails** of a Policy Engine. Every action is auditable.
  * **Self-Healing & Resilience**: The framework is designed to anticipate and autonomously recover from failures.
  * **Continuous Learning**: Through its **Memory**, the system gets smarter and more efficient with every task it completes.

### Future Roadmap

This implementation represents a solid foundation. The vision for UF-Flow includes:

  * **V1.5: The Workflow Copilot**: Introduce runtime intelligence for assisted debugging and proactive failure warnings without ceding full control.
  * **V2.0: Single-Agent Autonomy**: Empower the Orchestrator with self-healing capabilities to automatically handle common failures based on learned memory and policies.
  * **V3.0: Multi-Agent Systems**: Evolve the framework to support swarms of specialized agents that can collaborate on complex, ambiguous goals.